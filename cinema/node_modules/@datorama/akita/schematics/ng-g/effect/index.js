"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const ts = require("typescript");
const string_1 = require("../utils/string");
const utils_1 = require("../utils");
function addImportToNgModule(options) {
    return (host) => {
        const modulePath = options.module;
        if (!modulePath) {
            return host;
        }
        if (!host.exists(modulePath)) {
            throw new Error(`Specified module path ${modulePath} does not exist`);
        }
        const text = host.read(modulePath);
        if (text === null) {
            throw new schematics_1.SchematicsException(`File ${modulePath} does not exist.`);
        }
        const sourceText = text.toString('utf-8');
        const source = ts.createSourceFile(modulePath, sourceText, ts.ScriptTarget.Latest, true);
        const effectsName = `${string_1.classify(`${options.name}Effects`)}`;
        const effectsModuleImport = utils_1.insertImport(source, modulePath, 'AkitaNgEffectsModule', '@datorama/akita-ng-effects');
        const effectsPath = `/${options.path}/` + (options.flat ? '' : string_1.dasherize(options.name) + '/') + (options.group ? 'effects/' : '') + string_1.dasherize(options.name) + '.effects';
        const relativePath = utils_1.buildRelativePath(modulePath, effectsPath);
        const effectsImport = utils_1.insertImport(source, modulePath, effectsName, relativePath);
        const effectsSetup = `[${effectsName}]`;
        // options.root && options.minimal ? `[]` : `[${effectsName}]`;
        const [effectsNgModuleImport] = utils_1.addImportToModule(source, modulePath, `AkitaNgEffectsModule.for${options.root ? 'Root' : 'Feature'}(${effectsSetup})`, relativePath);
        let changes = [effectsModuleImport, effectsNgModuleImport];
        if (!options.root || options.root) {
            changes = changes.concat([effectsImport]);
        }
        const recorder = host.beginUpdate(modulePath);
        for (const change of changes) {
            if (change instanceof utils_1.InsertChange) {
                recorder.insertLeft(change.pos, change.toAdd);
            }
        }
        host.commitUpdate(recorder);
        return host;
    };
}
function getEffectMethod(creators) {
    return creators ? 'createEffect' : 'Effect';
}
function getEffectStart(name, creators) {
    const effectName = string_1.classify(name);
    return creators ? `load${effectName}s$ = createEffect(() => {` + '\n    return this.actions$.pipe( \n' : '@Effect()\n' + `  load${effectName}s$ = this.actions$.pipe(`;
}
function getEffectEnd(creators) {
    return creators ? '  );\n' + '  });' : ');';
}
function default_1(options) {
    return (host, context) => {
        options.path = utils_1.getProjectPath(host, options);
        if (options.module) {
            options.module = utils_1.findModuleFromOptions(host, options);
        }
        const parsedPath = utils_1.parseName({ path: options.path, name: options.name || '' });
        options.name = parsedPath.name;
        options.path = parsedPath.path;
        const templateSource = schematics_1.apply(schematics_1.url('./files'), [
            options.skipTests ? schematics_1.filter((path) => !path.endsWith('.spec.ts.template')) : schematics_1.noop(),
            options.root && options.minimal ? schematics_1.filter((_) => false) : schematics_1.noop(),
            schematics_1.applyTemplates(Object.assign(Object.assign(Object.assign({}, utils_1.stringUtils), { 'if-flat': (s) => utils_1.stringUtils.group(options.flat ? '' : s, options.group ? 'effects' : ''), effectMethod: getEffectMethod(options.creators), effectStart: getEffectStart(options.name, options.creators), effectEnd: getEffectEnd(options.creators) }), options)),
            schematics_1.move(parsedPath.path),
        ]);
        return schematics_1.chain([schematics_1.branchAndMerge(schematics_1.chain([addImportToNgModule(options), schematics_1.mergeWith(templateSource)]))])(host, context);
    };
}
exports.default = default_1;
//# sourceMappingURL=index.js.map