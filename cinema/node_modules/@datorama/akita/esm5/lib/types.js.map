{"version":3,"file":"types.js","sourceRoot":"ng://@datorama/akita/","sources":["lib/types.ts"],"names":[],"mappings":"","sourcesContent":["import { SortByOptions } from './queryConfig';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { QueryEntity } from './queryEntity';\n\nexport interface HashMap<T> {\n  [id: string]: T;\n}\n\nexport interface EntityState<E = any, IDType = any> {\n  entities?: HashMap<E>;\n  ids?: IDType[];\n  loading?: boolean;\n  error?: any;\n  [key: string]: any;\n}\n\nexport interface Entities<E> {\n  entities: HashMap<E>;\n  ids: ID[];\n}\n\nexport interface ActiveState<T = ID> {\n  active: T | null;\n}\n\nexport interface MultiActiveState<T = ID> {\n  active: T[];\n}\n\nexport interface SelectOptions<E> extends SortByOptions<E> {\n  asObject?: boolean;\n  filterBy?: ((entity: E, index?: number) => boolean) | ((entity: E, index?: number) => boolean)[] | undefined;\n  limitTo?: number;\n}\n\nexport type StateWithActive<State> = State & (ActiveState | MultiActiveState);\nexport type UpdateStateCallback<State, NewState extends Partial<State> = Partial<State>> = (state: State) => NewState | void;\nexport type UpsertStateCallback<State, NewState extends Partial<State> = Partial<State>> = (state: State | {}) => NewState;\nexport type CreateStateCallback<State, NewState extends Partial<State>, IDType> = (id: IDType, newState: NewState) => State;\nexport type UpdateEntityPredicate<E> = (entity: E) => boolean;\nexport type ID = number | string;\nexport type IDS = ID | ID[];\nexport type PreAddEntity<Entity> = (entity: Entity) => Entity;\nexport type PreUpdateEntity<Entity> = (prevEntity: Entity, nextEntity: Entity) => Entity;\n\nexport type StoreCache = {\n  active: BehaviorSubject<boolean>;\n  ttl: number;\n};\nexport type ArrayProperties<T> = { [K in keyof T]: T[K] extends any[] ? K : never }[keyof T];\nexport type ItemPredicate<Item = any> = (item: Item, index?: number) => boolean;\nexport type MaybeAsync<T = any> = Promise<T> | Observable<T> | T;\nexport type EntityUICreateFn<EntityUI = any, Entity = any> = EntityUI | ((entity: Entity) => EntityUI);\nexport type Constructor<T = any> = new (...args: any[]) => T;\nexport type OrArray<Type> = Type | Type[];\nexport type getEntityType<S> = S extends EntityState<infer I> ? I : never;\nexport type getIDType<S> = S extends EntityState<any, infer I> ? I : never;\nexport type getQueryEntityState<T extends QueryEntity<any>> = T extends QueryEntity<infer S> ? S : never;\n\nexport type ArrayFuncs = ((...a: any[]) => any)[];\nexport type ReturnTypes<T extends ArrayFuncs> = { [P in keyof T]: T[P] extends (...a: any[]) => infer R ? R : never };\n"]}