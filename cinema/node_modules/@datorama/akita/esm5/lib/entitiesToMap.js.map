{"version":3,"file":"entitiesToMap.js","sourceRoot":"ng://@datorama/akita/","sources":["lib/entitiesToMap.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAChC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAE5C,YAAY;AACZ,MAAM,UAAU,aAAa,CAA8B,KAAQ,EAAE,OAAO;IAC1E,IAAM,GAAG,GAAG,EAAE,CAAC;IACP,IAAA,QAAQ,GAAc,OAAO,SAArB,EAAE,OAAO,GAAK,OAAO,QAAZ,CAAa;IAC9B,IAAA,GAAG,GAAe,KAAK,IAApB,EAAE,QAAQ,GAAK,KAAK,SAAV,CAAW;IAEhC,IAAI,CAAC,QAAQ,IAAI,CAAC,OAAO,EAAE;QACzB,OAAO,QAAQ,CAAC;KACjB;IACD,IAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,KAAK,CAAC;IAE1C,IAAI,QAAQ,IAAI,QAAQ,EAAE;QACxB,IAAI,KAAK,GAAG,CAAC,CAAC;gCACL,CAAC,EAAM,QAAM;YACpB,IAAI,KAAK,KAAK,OAAO;+BAAQ;YAC7B,IAAM,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YAClB,IAAM,MAAM,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;YAC5B,IAAM,OAAO,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,UAAA,EAAE,IAAI,OAAA,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,EAAb,CAAa,CAAC,CAAC;YACjE,IAAI,OAAO,EAAE;gBACX,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC;gBACjB,KAAK,EAAE,CAAC;aACT;;QARH,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,QAAM,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,QAAM,EAAE,CAAC,EAAE;kCAA3C,CAAC,EAAM,QAAM;;;SASrB;KACF;SAAM;QACL,IAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,IAAI,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;gCAEvD,CAAC;YACR,IAAM,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YAClB,IAAM,MAAM,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;YAE5B,IAAI,CAAC,QAAQ,EAAE;gBACb,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC;;aAElB;YAED,IAAM,OAAO,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,UAAA,EAAE,IAAI,OAAA,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,EAAb,CAAa,CAAC,CAAC;YACjE,IAAI,OAAO,EAAE;gBACX,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC;aAClB;;QAZH,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE;oBAA3B,CAAC;SAaT;KACF;IAED,OAAO,GAAG,CAAC;AACb,CAAC","sourcesContent":["import { EntityState } from './types';\nimport { isNil } from './isNil';\nimport { coerceArray } from './coerceArray';\n\n// @internal\nexport function entitiesToMap<S extends EntityState<E>, E>(state: S, options) {\n  const map = {};\n  const { filterBy, limitTo } = options;\n  const { ids, entities } = state;\n\n  if (!filterBy && !limitTo) {\n    return entities;\n  }\n  const hasLimit = isNil(limitTo) === false;\n\n  if (filterBy && hasLimit) {\n    let count = 0;\n    for (let i = 0, length = ids.length; i < length; i++) {\n      if (count === limitTo) break;\n      const id = ids[i];\n      const entity = entities[id];\n      const allPass = coerceArray(filterBy).every(fn => fn(entity, i));\n      if (allPass) {\n        map[id] = entity;\n        count++;\n      }\n    }\n  } else {\n    const finalLength = Math.min(limitTo || ids.length, ids.length);\n\n    for (let i = 0; i < finalLength; i++) {\n      const id = ids[i];\n      const entity = entities[id];\n\n      if (!filterBy) {\n        map[id] = entity;\n        continue;\n      }\n\n      const allPass = coerceArray(filterBy).every(fn => fn(entity, i));\n      if (allPass) {\n        map[id] = entity;\n      }\n    }\n  }\n\n  return map;\n}\n"]}