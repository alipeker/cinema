{"version":3,"file":"updateEntities.js","sourceRoot":"ng://@datorama/akita/","sources":["lib/updateEntities.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject } from 'rxjs';\nimport { EntityState, ID, PreUpdateEntity, UpdateStateCallback } from './types';\nimport { isFunction } from './isFunction';\nimport { hasEntity } from './hasEntity';\nimport { isPlainObject } from './isPlainObject';\n\nexport type UpdateEntitiesParams<State, Entity> = {\n  state: State;\n  ids: any[];\n  idKey: string;\n  newStateOrFn: UpdateStateCallback<Entity> | Partial<Entity> | Partial<State>;\n  preUpdateEntity: PreUpdateEntity<Entity>;\n  producerFn;\n  onEntityIdChanges: (oldId: any, newId: any) => void;\n};\n\n// @internal\nexport function updateEntities<S extends EntityState<E>, E>({ state, ids, idKey, newStateOrFn, preUpdateEntity, producerFn, onEntityIdChanges }: UpdateEntitiesParams<S, E>) {\n  const updatedEntities = {};\n\n  let isUpdatingIdKey = false;\n  let idToUpdate: ID;\n\n  for (const id of ids) {\n    // if the entity doesn't exist don't do anything\n    if (hasEntity(state.entities, id) === false) {\n      continue;\n    }\n\n    const oldEntity = state.entities[id];\n    let newState;\n    if (isFunction(newStateOrFn)) {\n      newState = isFunction(producerFn) ? producerFn(oldEntity, newStateOrFn) : newStateOrFn(oldEntity);\n    } else {\n      newState = newStateOrFn;\n    }\n\n    const isIdChanged = newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey];\n    let newEntity: E;\n    idToUpdate = id;\n\n    if (isIdChanged) {\n      isUpdatingIdKey = true;\n      idToUpdate = newState[idKey];\n    }\n\n    const merged = {\n      ...oldEntity,\n      ...newState,\n    };\n\n    if (isPlainObject(oldEntity)) {\n      newEntity = merged;\n    } else {\n      /**\n       * In case that new state is class of it's own, there's\n       * a possibility that it will be different than the old\n       * class.\n       * For example, Old state is an instance of animal class\n       * and new state is instance of person class.\n       * To avoid run over new person class with the old animal\n       * class we check if the new state is a class of it's own.\n       * If so, use it. Otherwise, use the old state class\n       */\n      if (isPlainObject(newState)) {\n        newEntity = new (oldEntity as any).constructor(merged);\n      } else {\n        newEntity = new (newState as any).constructor(merged);\n      }\n    }\n\n    updatedEntities[idToUpdate] = preUpdateEntity(oldEntity, newEntity);\n  }\n\n  let updatedIds = state.ids;\n  let stateEntities = state.entities;\n\n  if (isUpdatingIdKey) {\n    const [id] = ids;\n    const { [id]: deletedEntity, ...rest } = state.entities;\n    stateEntities = rest;\n    updatedIds = state.ids.map((current) => (current === id ? idToUpdate : current));\n    onEntityIdChanges(id, idToUpdate);\n  }\n\n  return {\n    ...state,\n    entities: {\n      ...stateEntities,\n      ...updatedEntities,\n    },\n    ids: updatedIds,\n  };\n}\n"]}