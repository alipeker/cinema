{"version":3,"file":"entitiesToMap.js","sourceRoot":"ng://@datorama/akita/","sources":["lib/entitiesToMap.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAChC,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAC;AAE5C,YAAY;AACZ,MAAM,UAAU,aAAa,CAA8B,KAAQ,EAAE,OAAO;IAC1E,MAAM,GAAG,GAAG,EAAE,CAAC;IACf,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG,OAAO,CAAC;IACtC,MAAM,EAAE,GAAG,EAAE,QAAQ,EAAE,GAAG,KAAK,CAAC;IAEhC,IAAI,CAAC,QAAQ,IAAI,CAAC,OAAO,EAAE;QACzB,OAAO,QAAQ,CAAC;KACjB;IACD,MAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,KAAK,KAAK,CAAC;IAE1C,IAAI,QAAQ,IAAI,QAAQ,EAAE;QACxB,IAAI,KAAK,GAAG,CAAC,CAAC;QACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YACpD,IAAI,KAAK,KAAK,OAAO;gBAAE,MAAM;YAC7B,MAAM,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YAClB,MAAM,MAAM,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;YAC5B,MAAM,OAAO,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;YACjE,IAAI,OAAO,EAAE;gBACX,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC;gBACjB,KAAK,EAAE,CAAC;aACT;SACF;KACF;SAAM;QACL,MAAM,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,IAAI,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;QAEhE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;YACpC,MAAM,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;YAClB,MAAM,MAAM,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;YAE5B,IAAI,CAAC,QAAQ,EAAE;gBACb,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC;gBACjB,SAAS;aACV;YAED,MAAM,OAAO,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;YACjE,IAAI,OAAO,EAAE;gBACX,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC;aAClB;SACF;KACF;IAED,OAAO,GAAG,CAAC;AACb,CAAC","sourcesContent":["import { EntityState } from './types';\nimport { isNil } from './isNil';\nimport { coerceArray } from './coerceArray';\n\n// @internal\nexport function entitiesToMap<S extends EntityState<E>, E>(state: S, options) {\n  const map = {};\n  const { filterBy, limitTo } = options;\n  const { ids, entities } = state;\n\n  if (!filterBy && !limitTo) {\n    return entities;\n  }\n  const hasLimit = isNil(limitTo) === false;\n\n  if (filterBy && hasLimit) {\n    let count = 0;\n    for (let i = 0, length = ids.length; i < length; i++) {\n      if (count === limitTo) break;\n      const id = ids[i];\n      const entity = entities[id];\n      const allPass = coerceArray(filterBy).every(fn => fn(entity, i));\n      if (allPass) {\n        map[id] = entity;\n        count++;\n      }\n    }\n  } else {\n    const finalLength = Math.min(limitTo || ids.length, ids.length);\n\n    for (let i = 0; i < finalLength; i++) {\n      const id = ids[i];\n      const entity = entities[id];\n\n      if (!filterBy) {\n        map[id] = entity;\n        continue;\n      }\n\n      const allPass = coerceArray(filterBy).every(fn => fn(entity, i));\n      if (allPass) {\n        map[id] = entity;\n      }\n    }\n  }\n\n  return map;\n}\n"]}