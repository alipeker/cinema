{"version":3,"file":"updateEntities.js","sourceRoot":"ng://@datorama/akita/","sources":["lib/updateEntities.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAC;AAC1C,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAC;AACxC,OAAO,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAYhD,YAAY;AACZ,MAAM,UAAU,cAAc,CAA8B,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,YAAY,EAAE,eAAe,EAAE,UAAU,EAAE,iBAAiB,EAA8B;IACzK,MAAM,eAAe,GAAG,EAAE,CAAC;IAE3B,IAAI,eAAe,GAAG,KAAK,CAAC;IAC5B,IAAI,UAAc,CAAC;IAEnB,KAAK,MAAM,EAAE,IAAI,GAAG,EAAE;QACpB,gDAAgD;QAChD,IAAI,SAAS,CAAC,KAAK,CAAC,QAAQ,EAAE,EAAE,CAAC,KAAK,KAAK,EAAE;YAC3C,SAAS;SACV;QAED,MAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;QACrC,IAAI,QAAQ,CAAC;QACb,IAAI,UAAU,CAAC,YAAY,CAAC,EAAE;YAC5B,QAAQ,GAAG,UAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,SAAS,EAAE,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;SACnG;aAAM;YACL,QAAQ,GAAG,YAAY,CAAC;SACzB;QAED,MAAM,WAAW,GAAG,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,KAAK,SAAS,CAAC,KAAK,CAAC,CAAC;QAC3F,IAAI,SAAY,CAAC;QACjB,UAAU,GAAG,EAAE,CAAC;QAEhB,IAAI,WAAW,EAAE;YACf,eAAe,GAAG,IAAI,CAAC;YACvB,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;SAC9B;QAED,MAAM,MAAM,mCACP,SAAS,GACT,QAAQ,CACZ,CAAC;QAEF,IAAI,aAAa,CAAC,SAAS,CAAC,EAAE;YAC5B,SAAS,GAAG,MAAM,CAAC;SACpB;aAAM;YACL;;;;;;;;;eASG;YACH,IAAI,aAAa,CAAC,QAAQ,CAAC,EAAE;gBAC3B,SAAS,GAAG,IAAK,SAAiB,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;aACxD;iBAAM;gBACL,SAAS,GAAG,IAAK,QAAgB,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;aACvD;SACF;QAED,eAAe,CAAC,UAAU,CAAC,GAAG,eAAe,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;KACrE;IAED,IAAI,UAAU,GAAG,KAAK,CAAC,GAAG,CAAC;IAC3B,IAAI,aAAa,GAAG,KAAK,CAAC,QAAQ,CAAC;IAEnC,IAAI,eAAe,EAAE;QACnB,MAAM,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC;QACjB,MAAyC,KAAA,KAAK,CAAC,QAAQ,EAA/C,KAAC,EAAG,EAAE,aAAa,SAAA,EAAK,IAAI,cAA9B,uCAAgC,CAAiB,CAAC;QACxD,aAAa,GAAG,IAAI,CAAC;QACrB,UAAU,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;QACjF,iBAAiB,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;KACnC;IAED,uCACK,KAAK,KACR,QAAQ,kCACH,aAAa,GACb,eAAe,GAEpB,GAAG,EAAE,UAAU,IACf;AACJ,CAAC","sourcesContent":["import { Subject } from 'rxjs';\nimport { EntityState, ID, PreUpdateEntity, UpdateStateCallback } from './types';\nimport { isFunction } from './isFunction';\nimport { hasEntity } from './hasEntity';\nimport { isPlainObject } from './isPlainObject';\n\nexport type UpdateEntitiesParams<State, Entity> = {\n  state: State;\n  ids: any[];\n  idKey: string;\n  newStateOrFn: UpdateStateCallback<Entity> | Partial<Entity> | Partial<State>;\n  preUpdateEntity: PreUpdateEntity<Entity>;\n  producerFn;\n  onEntityIdChanges: (oldId: any, newId: any) => void;\n};\n\n// @internal\nexport function updateEntities<S extends EntityState<E>, E>({ state, ids, idKey, newStateOrFn, preUpdateEntity, producerFn, onEntityIdChanges }: UpdateEntitiesParams<S, E>) {\n  const updatedEntities = {};\n\n  let isUpdatingIdKey = false;\n  let idToUpdate: ID;\n\n  for (const id of ids) {\n    // if the entity doesn't exist don't do anything\n    if (hasEntity(state.entities, id) === false) {\n      continue;\n    }\n\n    const oldEntity = state.entities[id];\n    let newState;\n    if (isFunction(newStateOrFn)) {\n      newState = isFunction(producerFn) ? producerFn(oldEntity, newStateOrFn) : newStateOrFn(oldEntity);\n    } else {\n      newState = newStateOrFn;\n    }\n\n    const isIdChanged = newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey];\n    let newEntity: E;\n    idToUpdate = id;\n\n    if (isIdChanged) {\n      isUpdatingIdKey = true;\n      idToUpdate = newState[idKey];\n    }\n\n    const merged = {\n      ...oldEntity,\n      ...newState,\n    };\n\n    if (isPlainObject(oldEntity)) {\n      newEntity = merged;\n    } else {\n      /**\n       * In case that new state is class of it's own, there's\n       * a possibility that it will be different than the old\n       * class.\n       * For example, Old state is an instance of animal class\n       * and new state is instance of person class.\n       * To avoid run over new person class with the old animal\n       * class we check if the new state is a class of it's own.\n       * If so, use it. Otherwise, use the old state class\n       */\n      if (isPlainObject(newState)) {\n        newEntity = new (oldEntity as any).constructor(merged);\n      } else {\n        newEntity = new (newState as any).constructor(merged);\n      }\n    }\n\n    updatedEntities[idToUpdate] = preUpdateEntity(oldEntity, newEntity);\n  }\n\n  let updatedIds = state.ids;\n  let stateEntities = state.entities;\n\n  if (isUpdatingIdKey) {\n    const [id] = ids;\n    const { [id]: deletedEntity, ...rest } = state.entities;\n    stateEntities = rest;\n    updatedIds = state.ids.map((current) => (current === id ? idToUpdate : current));\n    onEntityIdChanges(id, idToUpdate);\n  }\n\n  return {\n    ...state,\n    entities: {\n      ...stateEntities,\n      ...updatedEntities,\n    },\n    ids: updatedIds,\n  };\n}\n"]}