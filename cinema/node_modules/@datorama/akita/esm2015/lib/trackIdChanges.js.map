{"version":3,"file":"trackIdChanges.js","sourceRoot":"ng://@datorama/akita/","sources":["lib/trackIdChanges.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAwC,EAAE,EAAuC,MAAM,MAAM,CAAC;AAC5G,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,EAAE,MAAM,gBAAgB,CAAC;AAI/D;;;;;;;;;GASG;AACH,MAAM,UAAU,cAAc,CAAuG,KAAQ;IAC3I,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAI,IAAI,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;AAC/D,CAAC;AAED,MAAM,cAAc;IAClB,YAAqB,KAAQ;QAAR,UAAK,GAAL,KAAK,CAAG;IAAG,CAAC;IAEjC,IAAI,CAAC,UAAyB,EAAE,MAAqB;QACnD,OAAO,MAAM;aACV,IAAI,CACH,KAAK,EAAE,EACP,SAAS,CAAC,CAAC,MAAM,EAAE,EAAE;YACnB,IAAI,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACvD,IAAI,OAAO,GAAG,KAAK,CAAC;YAEpB,OAAO,KAAK,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,sBAAsB,CAAC,CAAC,IAAI;YACrH,yCAAyC;YACzC,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,KAAK,MAAM,CAAC;YAC3C,qDAAqD;YACrD,GAAG,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;YAC3C,mFAAmF;YACnF,MAAM,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,KAAK,MAAM,IAAI,CAAC,OAAO,CAAC;YACvD,gDAAgD;YAChD,SAAS,CAAC,CAAC,MAAM,EAAE,EAAE,CACnB,IAAI,CAAC,KAAK;iBACP,YAAY,CAAC,CAAC,MAAM,GAAG,MAAM,CAAC,KAAK,IAAI,MAAM,CAAC,CAAC;gBAChD,mCAAmC;iBAClC,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAChC,CACF,CAAC;QACJ,CAAC,CAAC,CACH;aACA,SAAS,CAAC,UAAU,CAAC,CAAC;IAC3B,CAAC;CACF","sourcesContent":["import { merge, MonoTypeOperatorFunction, Observable, of, Operator, Subscriber, TeardownLogic } from 'rxjs';\nimport { filter, first, switchMap, tap } from 'rxjs/operators';\nimport { QueryEntity } from './queryEntity';\nimport { EntityState, getEntityType, getQueryEntityState } from './types';\n\n/**\n * Track id updates of an entity and re-evaluation the query with the changed entity id.\n * Hint: Don't place the operator after other operators in the same pipeline as those will be skipped on\n * re-evaluation. Also, it can't be used with the selection operator, e.g <code>selectEntity(1, e => e.title)</code>\n * @param query The query from which the entity is selected.\n * @example\n *\n *   query.selectEntity(1).pipe(trackIdChanges(query)).subscribe(entity => { ... })\n *\n */\nexport function trackIdChanges<K extends QueryEntity<S, T>, S extends EntityState<T> = getQueryEntityState<K>, T = getEntityType<S>>(query: K): MonoTypeOperatorFunction<T> {\n  return (source) => source.lift<T>(new TrackIdChanges(query));\n}\n\nclass TrackIdChanges<K extends QueryEntity<S, T>, S extends EntityState<T>, T = getEntityType<S>> implements Operator<T, T> {\n  constructor(readonly query: K) {}\n\n  call(subscriber: Subscriber<T>, source: Observable<T>): TeardownLogic {\n    return source\n      .pipe(\n        first(),\n        switchMap((entity) => {\n          let currId = entity[this.query.__store__.config.idKey];\n          let pending = false;\n\n          return merge(of({ newId: undefined, oldId: currId, pending: false }), this.query.__store__.selectEntityIdChanges$).pipe(\n            // the new id must differ form the old id\n            filter((change) => change.oldId === currId),\n            // extract the current pending state of the id update\n            tap((change) => (pending = change.pending)),\n            // only update the selection query if the id update is already applied to the store\n            filter((change) => change.newId !== currId && !pending),\n            // build a selection query for the new entity id\n            switchMap((change) =>\n              this.query\n                .selectEntity((currId = change.newId || currId))\n                // skip undefined value if pending.\n                .pipe(filter(() => !pending))\n            )\n          );\n        })\n      )\n      .subscribe(subscriber);\n  }\n}\n"]}